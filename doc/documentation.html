<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>README Documentation</title>
  <link rel="icon" type="image/svg+xml" href="https://static.wikia.nocookie.net/logopedia/images/e/e3/Minecraft_Launcher.svg/revision/latest/scale-to-width-down/250?cb=20230616222246">
  <link rel="stylesheet" href="/static/files.css">
  <link id="hljs-theme" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-light.min.css" data-light="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-light.min.css" data-dark="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/c.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/cpp.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/java.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/bash.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/powershell.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/dos.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

:root {
  --surface: #ffffff;
  --border: #d8dee6;
  --text: #1f2a37;
  --muted: #5a6878;
  --accent: #1e40af;
  --accent-hover: #1b3a9a;
  --radius: 14px;
  --sticky-offset: 72px;
  --toc-width: 22rem;
  --sticky-height: 64px;
  --toc-top: var(--sticky-height);
  --canvas-padding: 1.5rem;
  --burger-space: 4.5rem;
  --scrollbar-thumb: #94a3b8;
  --scrollbar-track: #ffffff;
  --scrollbar-thumb-hover: #64748b;
}

body {
  background-color: #eef2ff;
  color: var(--text);
  word-wrap: break-word;
  padding-top: 0;
  overflow-x: hidden;
  overflow-y: auto;
}

.layout {
  height: auto;
  min-height: 100dvh;
  overflow: visible;
}

.content {
  overflow: visible;
}

/* Match mcweb home scrollbar styling. */
.toc-body,
#content pre,
#content table,
#content .code-block {
  scrollbar-color: var(--scrollbar-thumb) var(--scrollbar-track);
  scrollbar-width: thin;
}

.toc-body::-webkit-scrollbar,
#content pre::-webkit-scrollbar,
#content table::-webkit-scrollbar,
#content .code-block::-webkit-scrollbar {
  width: 28px;
  height: 28px;
}

.toc-body::-webkit-scrollbar-track,
#content pre::-webkit-scrollbar-track,
#content table::-webkit-scrollbar-track,
#content .code-block::-webkit-scrollbar-track {
  background: var(--scrollbar-track);
}

.toc-body::-webkit-scrollbar-thumb,
#content pre::-webkit-scrollbar-thumb,
#content table::-webkit-scrollbar-thumb,
#content .code-block::-webkit-scrollbar-thumb {
  background: var(--scrollbar-thumb);
  border-radius: 10px;
  border: 2px solid var(--scrollbar-track);
}

.toc-body::-webkit-scrollbar-thumb:hover,
#content pre::-webkit-scrollbar-thumb:hover,
#content table::-webkit-scrollbar-thumb:hover,
#content .code-block::-webkit-scrollbar-thumb:hover {
  background: var(--scrollbar-thumb-hover);
}

main {
  width: auto;
  max-width: none;
  margin: 12px;
  padding: var(--canvas-padding) var(--canvas-padding) 2rem;
  background: var(--surface);
  border-radius: var(--radius);
  box-shadow: none;
  transition: margin-left 220ms ease, margin-right 220ms ease;
  min-height: calc(100vh - var(--sticky-height));
  display: flex;
  flex-direction: column;
  align-items: center;
  overflow-x: hidden;
  line-height: 1.6;
}

@media (max-width: 600px) {
  :root {
    --canvas-padding: 0.9rem;
  }
}

@media (max-width: 1100px) {
  :root { --canvas-padding: 1rem; }

  main {
    margin-top: calc(var(--sticky-height) + 12px);
  }

  #stickyMenuLabel {
    display: none !important;
  }
}

@media (min-width: 1101px) {
  :root {
    --toc-top: 0px;
  }

  .sidebar {
    position: sticky;
    top: 12px;
    align-self: start;
    height: calc(100vh - 24px);
    overflow: auto;
  }

  main {
    /* Keep main pane strictly between nav and TOC with 12px gutters. */
    margin: 12px calc(var(--toc-width) + 24px) 12px 12px;
  }

  .toc-sidebar {
    transform: translateX(0);
  }

  .sticky-menu {
    display: none !important;
  }

  .sticky-header {
    display: none !important;
  }
}

article {
  overflow: visible;
  overflow-wrap: anywhere;
  word-break: break-word;
  min-width: 0;
}

#content {
  width: 100%;
  max-width: 100%;
  min-width: 0;
  overflow-x: hidden;
}

#content > :first-child {
  margin-top: 0;
}

#content > * {
  max-width: 100%;
  min-width: 0;
}

#content pre,
#content table,
#content .code-block {
  max-width: 100%;
  overflow-x: auto;
}

#content p,
#content li,
#content blockquote,
#content td,
#content th {
  overflow-wrap: anywhere;
  word-break: break-word;
}

/* Headings */
h1, h2, h3, h4, h5, h6 {
  margin-top: 1.5em;
  margin-bottom: 0.5em;
  font-weight: 600;
  line-height: 1.25;
  scroll-margin-top: var(--sticky-offset);
}

h1 {
  font-size: 2em;
  border-bottom: 1px solid var(--border);
  padding-bottom: 0.3em;
}

h2 {
  font-size: 1.5em;
  border-bottom: 1px solid var(--border);
  padding-bottom: 0.3em;
}

h3 {
  font-size: 1.25em;
}

h4 {
  font-size: 1em;
}

h5 {
  font-size: 0.875em;
}

h6 {
  font-size: 0.85em;
  color: var(--muted);
}

/* Paragraphs */
p {
  margin-bottom: 1em;
}

/* Links */
a {
  color: var(--accent);
  text-decoration: none;
  background-color: transparent;
  cursor: pointer;
}

a:hover,
a:active {
  text-decoration: underline;
}

/* Lists */
ul, ol {
  margin-bottom: 1em;
  padding-left: 4em;
}

ul {
  list-style-type: disc;
}

ol {
  list-style-type: decimal;
}

li {
  margin-bottom: 0.25em;
  margin-top: 0.25em;
}

li > p {
  margin-bottom: 0.5em;
}

li > ul,
li > ol {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

/* Code */
code {
  background-color: #eef2ff;
  border-radius: var(--radius);
  padding: 0.2em 0.4em;
  margin: 0;
  font-family: monospace;
  font-size: 0.875em;
  color: #0f172a;
}

pre {
  background-color: transparent;
  border-radius: var(--radius);
  padding: 1.5rem;
  overflow-x: auto;
  margin-bottom: 1em;
  line-height: 1.45;
}

pre code {
  background-color: transparent;
  border: 0;
  margin: 0;
  padding: 0;
  color: var(--text);
  font-size: 0.875em;
}

.hljs {
  background: transparent !important;
}

.tok-command {
  color: var(--accent);
  font-weight: 600;
}

.tok-flag {
  color: #a40e26;
}

.code-block {
  border: 1px solid var(--border);
  border-radius: var(--radius);
  margin-bottom: 1em;
  overflow: hidden;
  background: var(--surface);
  width: 100%;
  max-width: min(50vw, 80ch);
}

.code-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0.35rem 0.7rem;
  background: #eef2ff;
  border-bottom: 1px solid var(--border);
  font-size: 0.75rem;
  letter-spacing: 0.02em;
}

.code-lang {
  font-weight: 600;
  text-transform: lowercase;
  color: var(--muted);
}

.code-copy {
  appearance: none;
  border: 1px solid var(--border);
  background: var(--surface);
  color: var(--text);
  border-radius: var(--radius);
  padding: 0.2rem 0.5rem;
  font-size: 0.75rem;
  cursor: pointer;
}

.code-copy:hover {
  background: #eef2ff;
}

.code-copy:active {
  transform: translateY(1px);
}

.code-block pre {
  margin: 0;
  padding: 1rem;
  background: transparent;
  border-radius: var(--radius);
}
/* Blockquotes */
blockquote {
  padding: 0 1em;
  color: var(--muted);
  border-left: 0.25em solid var(--border);
  margin: 1em 0;
}

blockquote > :first-child {
  margin-top: 0;
}

blockquote > :last-child {
  margin-bottom: 0;
}

.md-alert {
  margin: 1em 0;
  padding: 0.2rem 0.8rem;
  border-left: 4px solid #d3b300;
  color: #9a6700;
  background: transparent;
}

.md-alert-title {
  font-weight: 700;
  margin-bottom: 0.2rem;
  display: flex;
  align-items: center;
  gap: 0.4rem;
  color: inherit;
}

.md-alert-warning {
  border-left-color: #d29922;
  color: #9a6700;
}

.md-alert-note {
  border-left-color: var(--accent);
  color: var(--accent);
}

.md-alert-tip {
  border-left-color: #2da44e;
  color: #1a7f37;
}

.md-alert-important {
  border-left-color: #d35f75;
  color: #b42318;
}

.md-alert-caution {
  border-left-color: #f1a10b;
  color: #9a6700;
}

/* Horizontal rule */
hr {
  background-color: var(--border);
  border: 0;
  height: 0.25em;
  margin: 1.5em 0;
  padding: 0;
}

/* Tables */
table {
  border-collapse: collapse;
  width: 100%;
  margin-bottom: 1em;
  display: block;
  overflow-x: auto;
  max-width: 100%;
}

table tr {
  background-color: var(--surface);
  border-top-color: var(--border);
  border-top-style: solid;
  border-top-width: 1px;
}

table tr:nth-child(2n) {
  background-color: #eef2ff;
}

table th {
  background-color: #eef2ff;
  border: 1px solid var(--border);
  font-weight: 600;
  padding: 0.75rem;
  text-align: left;
}

table td {
  border: 1px solid var(--border);
  padding: 0.75rem;
}

/* Images */
img {
  max-width: 100%;
  height: auto;
  display: block;
  margin: 1em 0;
}

.badge-row {
  display: flex;
  flex-wrap: wrap;
  gap: 0.2rem;
  align-items: center;
  margin: 0.5rem 0;
}

.badge-row img {
  display: block;
  margin: 0;
}

/* Strong and Em */
strong {
  font-weight: 600;
}

em {
  font-style: italic;
}

/* Strikethrough */
del {
  text-decoration: line-through;
  color: var(--muted);
}

/* Loading and error states */
.error {
  background-color: #fef2f2;
  border: 1px solid #fecaca;
  border-radius: var(--radius);
  padding: 1rem;
  color: var(--text);
  margin: 1rem 0;
}

.loading {
  color: var(--muted);
  font-style: italic;
}

/* Floating Back to Top/TOC button */
.back-to-top {
  position: fixed;
  right: 1.25rem;
  bottom: 1.25rem;
  z-index: 1000;
  display: none;
  align-items: center;
  gap: 0.4rem;
  padding: 0.6rem 0.9rem;
  border-radius: 999px;
  background: var(--accent);
  color: #ffffff;
  font-size: 0.875rem;
  font-weight: 600;
  box-shadow: 0 6px 18px rgba(0, 0, 0, 0.15);
  border: none;
  cursor: pointer;
  text-decoration: none;
}

.back-to-top:hover {
  background: var(--accent-hover);
  text-decoration: none;
}

@media (max-width: 1100px) {
  .back-to-top {
    display: inline-flex;
  }
}

@media print {
  .back-to-top {
    display: none !important;
  }

  .sticky-header {
    display: none !important;
  }

  .toc-sidebar {
    display: none !important;
    visibility: hidden !important;
  }
}

/* Sticky section header */
.sticky-header {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  z-index: 1100;
  display: block;
  height: var(--sticky-height);
  padding: 0 1.2rem;
  background: var(--surface);
  border-bottom: 1px solid var(--border);
  font-weight: 700;
  color: var(--text);
  font-size: 1.5rem;
  box-shadow: 0 1px 4px rgba(0, 0, 0, 0.04);
  transition: transform 220ms ease, left 220ms ease, width 220ms ease;
}

.sticky-inner {
  display: flex;
  align-items: center;
  height: 100%;
  width: 100%;
  padding-left: max(var(--canvas-padding), var(--burger-space));
  transition: padding-left 220ms ease;
}

.sticky-menu {
  appearance: none;
  border: none;
  background: transparent;
  color: var(--text);
  border-radius: var(--radius);
  height: 44px;
  padding: 0 0.7rem;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 0.35rem;
  transition: transform 220ms ease, background 200ms ease;
  position: absolute;
  left: 1.2rem;
  top: 50%;
  transform: translateY(-50%);
}

.sticky-menu-label {
  font-size: 0.95rem;
  font-weight: 600;
  letter-spacing: 0.01em;
  white-space: nowrap;
}

.sticky-menu-lines {
  display: inline-flex;
  flex-direction: column;
  gap: 3px;
}

.sticky-menu-lines span {
  display: block;
  width: 18px;
  height: 2px;
  background: currentColor;
  border-radius: 999px;
  transition: transform 200ms ease, opacity 200ms ease;
  transform-origin: center;
}

.sticky-menu.is-open .sticky-menu-lines span:nth-child(1) {
  transform: translateY(5px) rotate(45deg);
}

.sticky-menu.is-open .sticky-menu-lines span:nth-child(2) {
  opacity: 0;
}

.sticky-menu.is-open .sticky-menu-lines span:nth-child(3) {
  transform: translateY(-5px) rotate(-45deg);
}

.sticky-title {
  font-weight: 700;
  flex: 1 1 auto;
  min-width: 0;
  line-height: 1.2;
  overflow: hidden;
  word-break: break-word;
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-line-clamp: 2;
}

.sticky-menu:hover {
  background: rgba(15, 23, 42, 0.08);
}

/* TOC sidebar */
.toc-sidebar {
  position: fixed;
  top: calc(var(--toc-top) + 12px);
  left: auto;
  right: 12px;
  width: var(--toc-width);
  height: calc(100vh - var(--toc-top) - 24px);
  max-height: calc(100vh - var(--toc-top) - 24px);
  overflow: hidden;
  background: var(--surface);
  border: none;
  border-radius: var(--radius);
  box-shadow: none;
  padding: 0.75rem 0.9rem 0.9rem;
  z-index: 1050;
  transform: translateX(calc(100% + 12px));
  transition: transform 240ms ease;
  display: flex;
  flex-direction: column;
}


.toc-sidebar-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 0.75rem;
  margin-bottom: 0.5rem;
  font-weight: 700;
  font-size: 0.95rem;
}


.toc-body ul {
  list-style: none;
  padding-left: 0.6rem;
  margin: 0;
}

.toc-body {
  flex: 1 1 auto;
  overflow: auto;
  min-height: 0;
}

.toc-body li {
  margin: 0.35rem 0;
}

.toc-item {
  display: block;
  white-space: normal;
  word-break: break-word;
}

.toc-item.is-active {
  background: rgba(30, 64, 175, 0.12);
  border-radius: var(--radius);
  padding: 0.15rem 0.35rem;
}


.toc-item.level-3 {
  margin-left: 1.25rem;
  font-size: 0.95rem;
}

@media (max-width: 960px) {
  .sticky-inner {
    gap: 0.75rem;
  }
}

@media (max-width: 900px) {
  .toc-sidebar {
    z-index: 1000;
  }
}

.toc-sidebar.is-visible {
  transform: translateX(0);
}

@media (max-width: 900px) {
  .sticky-header {
    padding-left: var(--canvas-padding);
  }

  .sticky-menu {
    left: var(--canvas-padding);
  }
}

@media (max-width: 700px) {
  .sticky-header {
    padding: 0 0.9rem;
  }
}

@media (max-width: 480px) {
  .sticky-header {
    padding: 0 0.75rem;
    gap: 0.6rem;
  }

  .sticky-menu-lines span {
    width: 16px;
  }
}

@media (prefers-color-scheme: dark) {
  :root {
    --scrollbar-thumb: #334155;
    --scrollbar-track: #11161d;
    --scrollbar-thumb-hover: #475569;
  }

  body {
    background-color: #0d1117;
    color: #e6edf3;
  }

  h1 {
    border-bottom-color: #334155;
  }

  h2 {
    background: #1f2733;
  }

  h6 {
    color: #9fb0c6;
  }

  a {
    color: #7aa2ff;
  }

  code {
    background-color: #161b22;
    color: #79c0ff;
  }

  pre {
    background-color: transparent;
  }

  pre code {
    color: #e6edf3;
  }

  .tok-command {
    color: #79c0ff;
  }

  .tok-flag {
    color: #ff7b72;
  }

  .code-block {
    border-color: #334155;
    background: #161b22;
  }

  .code-header {
    background: #1f2733;
    border-bottom-color: #334155;
  }

  .code-lang {
    color: #9fb0c6;
  }

  .code-copy {
    border-color: #334155;
    background: #1f2733;
    color: #e6edf3;
  }

  .code-copy:hover {
    background: #161b22;
  }

  blockquote {
    color: #9fb0c6;
    border-left-color: #334155;
  }

  .md-alert {
    color: #f2cc60;
  }

  .md-alert-warning {
    border-left-color: #d29922;
    color: #f2cc60;
  }

  .md-alert-note {
    border-left-color: #58a6ff;
    color: #58a6ff;
  }

  .md-alert-tip {
    border-left-color: #3fb950;
    color: #3fb950;
  }

  .md-alert-important {
    border-left-color: #f778ba;
    color: #f778ba;
  }

  .md-alert-caution {
    border-left-color: #e3b341;
    color: #e3b341;
  }

  hr {
    background-color: #334155;
  }

  table tr {
    background-color: #161b22;
    border-top-color: #334155;
  }

  table tr:nth-child(2n) {
    background-color: #1f2733;
  }

  table th {
    background-color: #1f2733;
    border-color: #334155;
  }

  table td {
    border-color: #334155;
  }

  del {
    color: #9fb0c6;
  }

  .error {
    background-color: #2d1d1d;
    border-color: #663333;
    color: #f0f6fc;
  }

  .loading {
    color: #9fb0c6;
  }

  .back-to-top {
    background: #1d4ed8;
    color: #ffffff;
  }


  .sidebar {
    background: #161b22;
    color: #e6edf3;
  }

  .sidebar-title {
    color: #9fb0c6;
  }

  .nav-link {
    background: #253247;
    color: #dbe7ff;
  }

  .nav-link:hover {
    background: #3b4e6a;
    color: #f8fbff;
  }

  .nav-link.active {
    background: #1d4ed8;
    color: #ffffff;
  }

  .nav-toggle {
    background: #161b22;
    color: #e6edf3;
    border-color: #334155;
  }

  .nav-toggle-bar {
    background: #e6edf3;
  }

  .sticky-header {
    background: #161b22;
    border-bottom-color: #334155;
    color: #e6edf3;
  }

  .sticky-menu {
    color: #e6edf3;
  }

  .sticky-menu:hover {
    background: rgba(148, 163, 184, 0.18);
  }

  main {
    background: #161b22;
  }

  .toc-sidebar {
    background: #161b22;
  }

  .toc-item.is-active {
    background: rgba(31, 111, 235, 0.18);
  }

}

  </style>
</head>
<body>
  <button id="nav-toggle" class="nav-toggle" type="button" aria-label="Toggle navigation" aria-expanded="false">
    <span class="nav-toggle-bar"></span>
    <span class="nav-toggle-bar"></span>
    <span class="nav-toggle-bar"></span>
  </button>
  <div id="nav-backdrop" class="nav-backdrop"></div>
  <div class="layout">
    <aside id="side-nav" class="sidebar" aria-label="Primary navigation">
      <div class="sidebar-title">Navigation</div>
      <a class="nav-link" href="/">Home</a>
      <a class="nav-link" href="/backups">Backups</a>
      <a class="nav-link" href="/minecraft-logs">Log Files</a>
      <a class="nav-link" href="/crash-logs">Crash Reports</a>
      <a class="nav-link active" href="/readme">Readme</a>
    </aside>
  <div id="stickyHeader" class="sticky-header">
    <div class="sticky-inner">
      <button id="stickyMenu" class="sticky-menu" type="button" aria-label="Toggle table of contents">
        <span class="sticky-menu-lines" aria-hidden="true">
          <span></span>
          <span></span>
          <span></span>
        </span>
        <span id="stickyMenuLabel" class="sticky-menu-label" hidden>Table of Contents</span>
      </button>
      <span id="stickyHeaderTitle" class="sticky-title"></span>
    </div>
  </div>
  <aside id="tocSidebar" class="toc-sidebar" aria-label="Table of contents sidebar">
    <div class="toc-sidebar-header">
      <span>Contents</span>
    </div>
    <div id="tocSidebarBody" class="toc-body"></div>
  </aside>
  <main class="content">
    <article id="content">
    </article>
  </main>
  </div>

  <a id="backToTop" class="back-to-top" href="#top" aria-label="Back to top">Back to top</a>

  <script>
    // Configure marked for GitHub-flavored markdown
    marked.setOptions({
      breaks: true,
      gfm: true,
      headerIds: true,
      mangle: false,
      pedantic: false
    });

    // Custom renderer for better semantic HTML
    const renderer = new marked.Renderer();

    const slugCounts = new Map();

    const getUniqueSlug = (base) => {
      const count = slugCounts.get(base) || 0;
      slugCounts.set(base, count + 1);
      if (count === 0) return base;
      return `${base}-${count}`;
    };

    // Custom heading renderer with ID anchors
    renderer.heading = (token) => {
      const rawText = token.text.replace(/<[^>]*>/g, '');
      const id = rawText
        .toLowerCase()
        .trim()
        .replace(/[^\w\s-]/g, '')
        .replace(/\s+/g, '-')
        .replace(/-+/g, '-')
        .replace(/^-|-$/g, '');
      const uniqueId = getUniqueSlug(id);
      return `<h${token.depth} id="${uniqueId}">${token.text}</h${token.depth}>\n`;
    };

    // Custom link renderer
    renderer.link = (token) => {
      const href = token.href || '';
      const title = token.title ? ` title="${token.title}"` : '';
      // In-page anchors should scroll within this document.
      if (href.startsWith('#')) {
        return `<a href="${href}"${title}>${token.text}</a>`;
      }
      return `<a href="${href}"${title} target="_blank" rel="noopener noreferrer">${token.text}</a>`;
    };

    // Custom image renderer
    renderer.image = (token) => {
      let src = token.href || token.url || token.src || '';
      if (src.startsWith('http://')) {
        src = src
          .replace(/^http:\/\/img\.shields\.io/i, 'https://img.shields.io')
          .replace(/^http:\/\/img\.badgesize\.io/i, 'https://img.badgesize.io')
          .replace(/^http:\/\/badgesize\.io/i, 'https://badgesize.io');
      }
      const alt = token.text || token.alt || '';
      return `<img src="${src}" alt="${alt}"${token.title ? ` title="${token.title}"` : ''}>`;
    };

    // Custom code block renderer with language support
    renderer.codespan = (token) => {
      return `<code>${token.text}</code>`;
    };

    // GitHub-style alert blocks (e.g., [!WARNING])
    renderer.blockquote = (token) => {
      const raw = token.text || '';
      const lines = raw.split('\n');
      const first = lines[0] ? lines[0].trim() : '';
      const match = first.match(/^\[!(NOTE|TIP|IMPORTANT|WARNING|CAUTION)\]\s*(.*)$/i);
      if (!match) {
        return `<blockquote>${marked.parse(raw)}</blockquote>`;
      }
      const kind = match[1].toLowerCase();
      const title = match[1].toUpperCase();
      const rest = [match[2], ...lines.slice(1)].filter(Boolean).join('\n');
      return `
        <div class="md-alert md-alert-${kind}">
          <div class="md-alert-title">${title}</div>
          <div class="md-alert-body">${marked.parse(rest)}</div>
        </div>
      `;
    };

    renderer.code = (token) => {
      const lang = token.lang || 'plaintext';
      const normalized = normalizeLang(lang);
      const label = escapeHtml(lang || 'text');
      return `
        <div class="code-block">
          <div class="code-header">
            <span class="code-lang">${label}</span>
            <button class="code-copy" type="button" aria-label="Copy code">Copy</button>
          </div>
          <pre><code class="hljs language-${normalized}">${highlightCode(normalized, token.text)}</code></pre>
        </div>
      `;
    };

    marked.setOptions({ renderer });

    const escapeHtml = (value) => {
      return value
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    };

    const normalizeMarkdown = (md) => {
      const lines = String(md || '').split(/\r?\n/);
      let inFence = false;
      return lines.map(line => {
        const fenceMatch = line.match(/^\s*```/);
        if (fenceMatch) {
          inFence = !inFence;
          return line;
        }
        if (!inFence) {
          if (/^\s*!\[[^\]]*]\([^)]+\)\s*$/.test(line)) {
            return line.trimStart();
          }
        }
        return line;
      }).join('\n');
    };

    const forceInlineImages = (md) => {
      const lines = String(md || '').split(/\r?\n/);
      let inFence = false;
      return lines.map(line => {
        const fenceMatch = line.match(/^\s*```/);
        if (fenceMatch) {
          inFence = !inFence;
          return line;
        }
        if (inFence) return line;
        if (line.includes('<img')) return line;

        let out = '';
        let i = 0;
        while (i < line.length) {
          const start = line.indexOf('![', i);
          if (start === -1) {
            out += line.slice(i);
            break;
          }
          out += line.slice(i, start);
          const altEnd = line.indexOf('](', start);
          if (altEnd === -1) {
            out += line.slice(start);
            break;
          }
          const altText = line.slice(start + 2, altEnd);
          let j = altEnd + 2;
          let depth = 1;
          let urlStart = j;
          while (j < line.length && depth > 0) {
            const ch = line[j];
            if (ch === '(') depth += 1;
            if (ch === ')') depth -= 1;
            j += 1;
          }
          if (depth !== 0) {
            out += line.slice(start);
            break;
          }
          const urlRaw = line.slice(urlStart, j - 1).trim();
          let safeUrl = urlRaw;
          if (safeUrl.startsWith('http://')) {
            safeUrl = safeUrl
              .replace(/^http:\/\/img\.shields\.io/i, 'https://img.shields.io')
              .replace(/^http:\/\/img\.badgesize\.io/i, 'https://img.badgesize.io')
              .replace(/^http:\/\/badgesize\.io/i, 'https://badgesize.io');
          }
          out += `<img src="${safeUrl}" alt="${altText}">`;
          i = j;
        }
        return out;
      }).join('\n');
    };

    const resolveReferenceImages = (md) => {
      const lines = String(md || '').split(/\r?\n/);
      const refs = {};
      for (let i = 0; i < lines.length; i += 1) {
        const line = lines[i];
        const def = line.match(/^\s*\[([^\]]+)\]:\s*(<[^>]+>|\S+)?\s*(?:"([^"]+)"|'([^']+)'|\(([^)]+)\))?\s*$/);
        if (!def) continue;
        const key = def[1].toLowerCase();
        let rawUrl = def[2] || '';
        let title = def[3] || def[4] || def[5] || '';

        if (!rawUrl) {
          let j = i + 1;
          while (j < lines.length && /^\s+/.test(lines[j])) {
            const candidate = lines[j].trim();
            if (candidate) {
              rawUrl = candidate;
              break;
            }
            j += 1;
          }
        }

        if (rawUrl) {
          rawUrl = rawUrl.startsWith('<') ? rawUrl.slice(1, -1) : rawUrl;
          refs[key] = { url: rawUrl, title };
        }
      }

      let inFence = false;
      return lines.map(line => {
        const fenceMatch = line.match(/^\s*```/);
        if (fenceMatch) {
          inFence = !inFence;
          return line;
        }
        if (inFence) return line;

        return line
          .replace(/\[!\[([^\]]*)]\[([^\]]*)]]\s*\[([^\]]*)]/g, (m, alt, imgKey, linkKey) => {
            const imgRefKey = (imgKey || alt || '').toLowerCase();
            const imgRef = refs[imgRefKey];
            const linkRefKey = (linkKey || '').toLowerCase();
            const linkRef = refs[linkRefKey];
            if (!imgRef) return m;
            const imgTitle = imgRef.title ? ` "${imgRef.title}"` : '';
            const img = `![${alt}](${imgRef.url}${imgTitle})`;
            if (!linkRef) return img;
            const linkTitle = linkRef.title ? ` "${linkRef.title}"` : '';
            return `[${img}](${linkRef.url}${linkTitle})`;
          })
          .replace(/!\[([^\]]*)]\[([^\]]*)]/g, (m, alt, key) => {
            const refKey = (key || alt || '').toLowerCase();
            const ref = refs[refKey];
            if (!ref) return m;
            const title = ref.title ? ` "${ref.title}"` : '';
            return `![${alt}](${ref.url}${title})`;
          })
          .replace(/!\[([^\]]*)]\[\]/g, (m, alt) => {
            const refKey = (alt || '').toLowerCase();
            const ref = refs[refKey];
            if (!ref) return m;
            const title = ref.title ? ` "${ref.title}"` : '';
            return `![${alt}](${ref.url}${title})`;
          });
      }).join('\n');
    };

    const normalizeLang = (lang) => {
      const normalized = String(lang || '').toLowerCase();
      if (['sh', 'shell', 'bash', 'zsh'].includes(normalized)) {
        return 'bash';
      }
      return normalized || 'plaintext';
    };

    const SANITIZE_ALLOWED_TAGS = new Set([
      'a', 'article', 'blockquote', 'br', 'code', 'del', 'div', 'em',
      'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'hr', 'img', 'li', 'ol',
      'p', 'pre', 'section', 'span', 'strong', 'table', 'tbody', 'td',
      'th', 'thead', 'tr', 'ul'
    ]);
    const SANITIZE_DROP_WITH_CONTENT = new Set([
      'script', 'style', 'iframe', 'object', 'embed', 'link', 'meta',
      'base', 'form', 'input', 'button', 'textarea', 'select', 'option'
    ]);
    const SANITIZE_GLOBAL_ATTRS = new Set(['class', 'id', 'aria-label', 'role']);
    const SANITIZE_ATTRS_BY_TAG = {
      a: new Set(['href', 'title', 'target', 'rel']),
      img: new Set(['src', 'alt', 'title', 'width', 'height', 'loading', 'decoding']),
      th: new Set(['colspan', 'rowspan']),
      td: new Set(['colspan', 'rowspan']),
      code: new Set(['class']),
      pre: new Set(['class']),
      div: new Set(['class', 'id']),
      span: new Set(['class', 'id'])
    };

    const isSafeUrl = (value, { allowAnchor = false } = {}) => {
      const raw = String(value || '').trim();
      if (!raw) return false;
      if (allowAnchor && raw.startsWith('#')) return true;
      const normalized = raw.replace(/[\u0000-\u001F\u007F\s]+/g, '').toLowerCase();
      if (!normalized) return false;
      if (
        normalized.startsWith('javascript:') ||
        normalized.startsWith('vbscript:') ||
        normalized.startsWith('data:')
      ) {
        return false;
      }
      if (
        normalized.startsWith('http://') ||
        normalized.startsWith('https://') ||
        normalized.startsWith('mailto:')
      ) {
        return true;
      }
      return !normalized.includes(':');
    };

    const sanitizeRenderedHtml = (html) => {
      const template = document.createElement('template');
      template.innerHTML = String(html || '');

      const walk = (node) => {
        if (!node) return;

        if (node.nodeType === Node.ELEMENT_NODE) {
          const el = node;
          const tag = el.tagName.toLowerCase();

          if (!SANITIZE_ALLOWED_TAGS.has(tag)) {
            if (SANITIZE_DROP_WITH_CONTENT.has(tag)) {
              el.remove();
              return;
            }
            const parent = el.parentNode;
            if (parent) {
              while (el.firstChild) {
                parent.insertBefore(el.firstChild, el);
              }
              parent.removeChild(el);
            } else {
              el.remove();
            }
            return;
          }

          const allowedAttrs = SANITIZE_ATTRS_BY_TAG[tag] || new Set();
          Array.from(el.attributes).forEach((attr) => {
            const name = attr.name.toLowerCase();
            const value = attr.value || '';

            if (name.startsWith('on')) {
              el.removeAttribute(attr.name);
              return;
            }
            if (!SANITIZE_GLOBAL_ATTRS.has(name) && !allowedAttrs.has(name)) {
              el.removeAttribute(attr.name);
              return;
            }
            if (name === 'href' && !isSafeUrl(value, { allowAnchor: true })) {
              el.removeAttribute(attr.name);
              return;
            }
            if (name === 'src' && !isSafeUrl(value)) {
              el.removeAttribute(attr.name);
              return;
            }
          });

          if (tag === 'a' && el.getAttribute('target') === '_blank') {
            el.setAttribute('rel', 'noopener noreferrer');
          }
        }

        Array.from(node.childNodes).forEach(walk);
      };

      Array.from(template.content.childNodes).forEach(walk);
      return template.innerHTML;
    };

    const highlightCode = (lang, code) => {
      const normalized = normalizeLang(lang);
      if (window.hljs) {
        if (normalized && hljs.getLanguage(normalized)) {
          const highlighted = hljs.highlight(code, { language: normalized }).value;
          if (normalized === 'bash') {
            return enhanceShellHighlight(highlighted);
          }
          return highlighted;
        }
        return hljs.highlightAuto(code).value;
      }
      return escapeHtml(code);
    };

    const enhanceShellHighlight = (html) => {
      return html.split('\n').map(line => {
        if (line.includes('<span')) return line;
        const withCommand = line.replace(/^(\s*)([^\s#]+)/, '$1<span class="tok-command">$2</span>');
        return withCommand.replace(/(\s)(-{1,2}[\w-]+)/g, '$1<span class="tok-flag">$2</span>');
      }).join('\n');
    };

    const applySystemTheme = () => {
      const themeLink = document.getElementById('hljs-theme');
      if (!themeLink) return;
      const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
      const nextHref = prefersDark ? themeLink.dataset.dark : themeLink.dataset.light;
      if (nextHref && themeLink.getAttribute('href') !== nextHref) {
        themeLink.setAttribute('href', nextHref);
      }
    };

    applySystemTheme();
    if (window.matchMedia) {
      const media = window.matchMedia('(prefers-color-scheme: dark)');
      if (typeof media.addEventListener === 'function') {
        media.addEventListener('change', applySystemTheme);
      }
    }

    // Fetch and render README
    const readmeURL = '/doc/README.md';
    const contentElement = document.getElementById('content');
    const backToTopButton = document.getElementById('backToTop');
    const stickyHeader = document.getElementById('stickyHeader');
    const stickyHeaderTitle = document.getElementById('stickyHeaderTitle');
    const stickyMenuButton = document.getElementById('stickyMenu');
    const stickyMenuLabel = document.getElementById('stickyMenuLabel');
    const tocSidebar = document.getElementById('tocSidebar');
    const tocSidebarBody = document.getElementById('tocSidebarBody');
    const navToggle = document.getElementById('nav-toggle');
    const sideNav = document.getElementById('side-nav');
    const navBackdrop = document.getElementById('nav-backdrop');
    const initMcwebNav = () => {
      if (!navToggle || !sideNav || !navBackdrop) return;

      const closeNav = () => {
        sideNav.classList.remove('open');
        navBackdrop.classList.remove('open');
        navToggle.classList.remove('nav-open');
        navToggle.setAttribute('aria-expanded', 'false');
      };

      const toggleNav = () => {
        const nextOpen = !sideNav.classList.contains('open');
        sideNav.classList.toggle('open', nextOpen);
        navBackdrop.classList.toggle('open', nextOpen);
        navToggle.classList.toggle('nav-open', nextOpen);
        navToggle.setAttribute('aria-expanded', nextOpen ? 'true' : 'false');
      };

      navToggle.addEventListener('click', toggleNav);
      navBackdrop.addEventListener('click', closeNav);
      window.addEventListener('resize', () => {
        if (window.innerWidth > 1100) closeNav();
      });
    };

    const addMediaListener = (mql, handler) => {
      if (!mql || !handler) return;
      if (typeof mql.addEventListener === 'function') {
        mql.addEventListener('change', handler);
      } else if (typeof mql.addListener === 'function') {
        mql.addListener(handler);
      }
    };

    const bindAnchorNavigation = (root, onNavigate) => {
      if (!root || !onNavigate) return;
      root.querySelectorAll('a[href^="#"]').forEach(link => {
        link.addEventListener('click', (event) => {
          const targetId = (link.getAttribute('href') || '').slice(1);
          if (!targetId) return;
          const target = document.getElementById(targetId);
          if (!target) return;
          event.preventDefault();
          onNavigate(target, targetId);
        });
      });
    };

    const processMarkdown = (mdText) => {
      let updateSticky = () => {};
      let updateActiveTocLink = () => {};
      let headings = [];
      let ticking = false;
      slugCounts.clear();
      const resolved = resolveReferenceImages(mdText);
      const normalized = normalizeMarkdown(resolved);
      const html = sanitizeRenderedHtml(marked.parse(forceInlineImages(normalized)));
      contentElement.innerHTML = html;

      const h1Title = contentElement.querySelector('h1');
      if (h1Title) {
        document.title = h1Title.textContent.trim();
      }

      // Remove in-content "Back to top" links from the README.
      const normalize = (value) => value
        .replace(/\s+/g, ' ')
        .replace(/[^\w\s]/g, '')
        .trim()
        .toLowerCase();

      const backToTopTargets = new Set(['#top', '#table-of-contents', '#toc', '#readme']);
      const backToTopLabels = [
        'back to top',
        'back to the top',
        'back to start',
        'back to contents',
        'back to table of contents',
        'return to top',
        'return to the top',
        'top'
      ].map(normalize);

      contentElement.querySelectorAll('a[href^="#"]').forEach(link => {
        const href = (link.getAttribute('href') || '').toLowerCase();
        const label = normalize(link.textContent || '');
        const isBackToTop = backToTopTargets.has(href) || backToTopLabels.includes(label);
        if (!isBackToTop) return;
        const parent = link.parentElement;
        link.remove();
        if (parent && parent.textContent.trim() === '') {
          parent.remove();
        }
      });

      const mergeBadgeRows = () => {
        const paragraphs = Array.from(contentElement.querySelectorAll('p'));
        paragraphs.forEach(p => {
          const nodes = Array.from(p.childNodes).filter(node => {
            if (node.nodeType === Node.TEXT_NODE) {
              return node.textContent.trim().length > 0;
            }
            return node.nodeType === Node.ELEMENT_NODE && node.tagName !== 'BR';
          });
          if (nodes.length === 0) return;
          const allBadges = nodes.every(node => {
            if (node.nodeType !== Node.ELEMENT_NODE) return false;
            if (node.tagName === 'IMG') return true;
            if (node.tagName === 'A') {
              return !!node.querySelector('img');
            }
            return false;
          });
          if (!allBadges) return;
          const wrapper = document.createElement('div');
          wrapper.className = 'badge-row';
          nodes.forEach(node => wrapper.appendChild(node));
          p.replaceWith(wrapper);
        });
      };

      const wireCopyButtons = () => {
        const buttons = contentElement.querySelectorAll('.code-copy');
        buttons.forEach(button => {
          button.addEventListener('click', async () => {
            const codeEl = button.closest('.code-block')?.querySelector('pre code');
            if (!codeEl) return;
            const text = codeEl.textContent || '';
            try {
              if (navigator.clipboard?.writeText) {
                await navigator.clipboard.writeText(text);
              } else {
                const textarea = document.createElement('textarea');
                textarea.value = text;
                textarea.style.position = 'fixed';
                textarea.style.opacity = '0';
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                textarea.remove();
              }
              const original = button.textContent;
              button.textContent = 'Copied';
              button.disabled = true;
              setTimeout(() => {
                button.textContent = original;
                button.disabled = false;
              }, 1200);
            } catch (err) {
              console.error('Copy failed:', err);
            }
          });
        });
      };

      mergeBadgeRows();
      wireCopyButtons();

      // Always point the floating button to top.
      backToTopButton.setAttribute('href', '#top');
      backToTopButton.textContent = 'Back to top';
      backToTopButton.addEventListener('click', (event) => {
        event.preventDefault();
        window.scrollTo({ top: 0, behavior: 'smooth' });
      });

      let tocPinned = true;
      let updateTocVisibility = () => {};
      const narrowMql = window.matchMedia('(max-width: 1100px)');
      const wideMql = window.matchMedia('(min-width: 1101px)');

      const syncStickyOffset = () => {
        const offset = (stickyHeader?.offsetHeight || 0) + 12;
        document.documentElement.style.setProperty('--sticky-offset', `${offset}px`);
      };

      const navigateToHeading = (target, targetId) => {
        scrollToTarget(target);
        history.pushState(null, '', `#${targetId}`);
      };

      const scrollToTarget = (target) => {
        if (!target) return;
        const offset = (stickyHeader?.offsetHeight || 0) + 12;
        const targetTop = target.getBoundingClientRect().top + window.scrollY - offset;
        window.scrollTo({ top: targetTop, behavior: 'smooth' });
      };

      const buildTocListFromHeadings = () => {
        const list = document.createElement('ul');
        const headingNodes = Array.from(contentElement.querySelectorAll('h2, h3'));
        headingNodes.forEach(heading => {
          if (heading.id === 'table-of-contents') return;
          const link = document.createElement('a');
          link.href = `#${heading.id}`;
          link.textContent = heading.textContent.trim();
          link.classList.add('toc-item', heading.tagName === 'H3' ? 'level-3' : 'level-2');
          const item = document.createElement('li');
          item.appendChild(link);
          list.appendChild(item);
        });
        return list;
      };

      const findInlineToc = () => {
        const candidates = Array.from(contentElement.querySelectorAll('ul, ol, p, div, section, nav'));
        let best = null;
        let bestScore = 0;

        candidates.forEach(node => {
          const anchors = node.querySelectorAll('a[href^="#"]');
          if (anchors.length < 4) return;
          const text = (node.textContent || '').trim();
          const wordCount = text ? text.split(/\s+/).length : 0;
          const density = anchors.length / Math.max(1, wordCount);
          const score = anchors.length + density * 8;
          if (score > bestScore) {
            bestScore = score;
            best = node;
          }
        });

        return best;
      };

      const inlineTocVisible = () => {
        const tocNode = findInlineToc();
        if (!tocNode) return;
        const findTocHeading = (node) => {
          let cursor = node.previousElementSibling;
          while (cursor) {
            if (/^H[1-6]$/.test(cursor.tagName)) {
              return cursor;
            }
            cursor = cursor.previousElementSibling;
          }
          return null;
        };
        const tocHeading = findTocHeading(tocNode);
        const shouldHide = wideMql.matches;
        tocNode.style.display = shouldHide ? 'none' : '';
        if (tocHeading) {
          tocHeading.style.display = shouldHide ? 'none' : '';
        }
      };

      // Build TOC sidebar from document headings (2 levels max).
      const buildTocSidebar = () => {
        const listEl = buildTocListFromHeadings();

        tocSidebarBody.innerHTML = '';
        tocSidebarBody.appendChild(listEl);
        bindAnchorNavigation(tocSidebarBody, navigateToHeading);

        updateTocVisibility = () => {
          const visible = tocPinned;
          tocSidebar.classList.toggle('is-visible', visible);
          stickyMenuLabel.hidden = !visible;
          if (narrowMql.matches) {
            stickyMenuButton.classList.toggle('is-open', visible);
          } else {
            stickyMenuButton.classList.remove('is-open');
          }
        };

        updateTocVisibility();
      };

      stickyMenuButton.addEventListener('click', () => {
        if (narrowMql.matches) {
          tocPinned = !tocPinned;
        } else {
          tocPinned = true;
        }
        updateTocVisibility();
      });

      const syncTocForWidth = () => {
        if (narrowMql.matches) {
          tocPinned = false;
          stickyMenuButton.hidden = false;
          stickyMenuButton.classList.remove('is-open');
        } else {
          tocPinned = true;
          stickyMenuButton.hidden = true;
          stickyMenuButton.classList.remove('is-open');
        }
        updateTocVisibility();
        inlineTocVisible();
      };
      syncTocForWidth();
      addMediaListener(narrowMql, syncTocForWidth);
      addMediaListener(wideMql, inlineTocVisible);

      buildTocSidebar();

      // Enable in-page anchor navigation after content is injected.
      bindAnchorNavigation(contentElement, navigateToHeading);

      // If the page loads with a hash, scroll to it.
      if (location.hash) {
        const target = document.getElementById(location.hash.slice(1));
        if (target) {
          scrollToTarget(target);
        }
      }

      const shouldTrackHeading = (heading) => {
        if (!heading) return false;
        if (heading.id === 'table-of-contents') return false;
        if (heading.tagName === 'H2' && heading.textContent.trim().toLowerCase() === 'table of contents') {
          return false;
        }
        const style = window.getComputedStyle(heading);
        return style.display !== 'none' && style.visibility !== 'hidden';
      };

      // Sticky section header (H2) with current subsection (H3).
      headings = Array.from(contentElement.querySelectorAll('h1, h2, h3')).filter(shouldTrackHeading);

      updateActiveTocLink = (currentH2, currentH3) => {
        const links = tocSidebarBody.querySelectorAll('a[href^="#"]');
        links.forEach(link => link.classList.remove('is-active'));
        const activeHeading = currentH3 || currentH2;
        if (!activeHeading) {
          const firstLink = links[0];
          if (firstLink) {
            firstLink.classList.add('is-active');
            firstLink.scrollIntoView({ block: 'nearest', inline: 'nearest' });
          }
          return;
        }
        const activeLink = tocSidebarBody.querySelector(`a[href="#${activeHeading.id}"]`);
        if (activeLink) {
          activeLink.classList.add('is-active');
          activeLink.scrollIntoView({ block: 'nearest', inline: 'nearest' });
        }
      };

      updateSticky = () => {
        ticking = false;
        let currentH1 = null;
        let currentH2 = null;
        let currentH3 = null;
        const scrollY = window.scrollY + (stickyHeader?.offsetHeight || 0) + 12;

        for (const heading of headings) {
          if (!shouldTrackHeading(heading)) continue;
          if (heading.offsetTop <= scrollY) {
            if (heading.tagName === 'H1') {
              currentH1 = heading;
              currentH2 = null;
              currentH3 = null;
            } else if (heading.tagName === 'H2') {
              currentH2 = heading;
              currentH3 = null;
            } else if (heading.tagName === 'H3' && currentH2) {
              currentH3 = heading;
            }
          }
        }

        const stripLeadingNumber = (text) => {
          return text.replace(/^\s*\d+(?:\.\d+)*\s*[-.)]?\s*/u, '');
        };

        const h1Text = currentH1 ? currentH1.textContent.trim() : '';
        const h2Text = currentH2 ? stripLeadingNumber(currentH2.textContent.trim()) : '';
        const h3Text = currentH3 ? stripLeadingNumber(currentH3.textContent.trim()) : '';
        const title = h3Text
          ? `${h2Text}: ${h3Text}`
          : (h2Text || h1Text || '');
        stickyHeaderTitle.textContent = title || '\u00a0';
        stickyHeader.hidden = false;
        updateActiveTocLink(currentH2, currentH3);
      };

      syncStickyOffset();
      updateTocVisibility();
      updateSticky();
      window.addEventListener('resize', syncStickyOffset);
      window.addEventListener('scroll', () => {
        if (!ticking) {
          window.requestAnimationFrame(updateSticky);
          ticking = true;
        }
      }, { passive: true });
    };

    const loadReadmeFromUrl = (url) => {
      if (!url) return;
      fetch(url)
        .then(res => {
          if (!res.ok) {
            throw new Error(`Network error ${res.status}: ${res.statusText}`);
          }
          return res.text();
        })
        .then(processMarkdown)
        .catch(err => {
          contentElement.textContent = `Error loading README: ${err.message}`;
          console.error('Failed to load README:', err);
        });
    };

    contentElement.innerHTML = '';
    initMcwebNav();
    loadReadmeFromUrl(readmeURL);
  </script>
</body>
</html>
